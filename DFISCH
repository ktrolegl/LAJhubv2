---date ts

local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
 
local Window = Rayfield:CreateWindow({
    Name = "LAJ HUBs | Dead Rails [BETA] ",
    LoadingTitle = "LAJ HUB | Loading...",
    LoadingSubtitle = "Please wait...",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnityNexus_Config"
    }
})
 
-- 🛡️ Stealth Anti-Ban & Anti-Detection System
local function StealthAntiBan()
    local success, err = pcall(function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local RunService = game:GetService("RunService")
        
        -- Reset any previous state
        _G.OriginalMethods = {}
        _G.Protected = true
        
        -- 1. Low-profile Anti-Detection
        -- Instead of huge values, use slightly increased values that don't trigger detection
        sethiddenproperty(LocalPlayer, "SimulationRadius", 30)
        sethiddenproperty(LocalPlayer, "MaximumSimulationRadius", 35)
        
        -- 2. Advanced Anti-Kick/Ban (Silent version)
        -- Store original methods to avoid detection
        _G.OriginalMethods.Kick = LocalPlayer.Kick
        _G.OriginalMethods.kick = LocalPlayer.kick
        
        -- Silently replace kick methods
        hookfunction(LocalPlayer.Kick, function(...)
            print("Kick attempted - blocked")
            return wait(9e9)
        end)
        
        -- 3. Basic Remote Detection Block (Hidden approach)
        local mt = getrawmetatable(game)
        local oldNamecall = mt.__namecall
        setreadonly(mt, false)
        
        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if method == "FireServer" or method == "InvokeServer" then
                -- Only block specific anti-cheat remotes we've identified
                local name = self.Name and string.lower(self.Name) or ""
                
                -- Known anti-cheat remote patterns in Dead Rails
                if name:find("security") or name:find("anti") or
                   name:find("check") or name:find("detect") then
                    return nil
                end
                
                -- If it's teleporting someone, let it pass but monitor it
                if method == "FireServer" and #args > 0 then
                    for _, arg in pairs(args) do
                        if typeof(arg) == "CFrame" and _G.TeleportInProgress then
                            -- This is likely our teleport, let it through
                            return oldNamecall(self, ...)
                        end
                    end
                end
            end
            
            return oldNamecall(self, ...)
        end)
        
        setreadonly(mt, true)
        
        -- 4. Silent Character Protection
        -- This avoids detection by being selective about what we modify
        RunService.Heartbeat:Connect(function()
            if not LocalPlayer.Character then return end
            
            -- Subtle network manipulation (less detectable)
            pcall(function()
                sethiddenproperty(LocalPlayer, "SimulationRadius", 30)
            end)
            
            -- Only apply speed if we requested it
            if LocalPlayer.Character:FindFirstChild("Humanoid") and _G.SpeedActive then
                LocalPlayer.Character.Humanoid.WalkSpeed = _G.CurrentWalkSpeed or 16
            end
        end)
        
        -- 5. Character Added Protection (Quiet version)
        LocalPlayer.CharacterAdded:Connect(function(character)
            wait(1) -- Wait for anti-cheat to finish its checks
            
            if character:FindFirstChild("Humanoid") then
                -- This flag indicates we can safely modify the character
                _G.CharacterReady = true
                
                -- If we had custom speed before, restore it
                if _G.CurrentWalkSpeed and _G.SpeedActive then
                    character.Humanoid.WalkSpeed = _G.CurrentWalkSpeed
                end
            end
        end)
        
        -- 6. Periodic Silent Cleanup (Minimal detection footprint)
        spawn(function()
            while wait(10) do
                if LocalPlayer.Character then
                    -- Only remove obvious anti-cheat scripts
                    for _, v in pairs(LocalPlayer.Character:GetDescendants()) do
                        if v:IsA("Script") and v.Name:lower():find("detect") then
                            -- Instead of destroying, disable it to avoid detection
                            pcall(function()
                                v.Disabled = true
                            end)
                        end
                    end
                end
            end
        end)
    end)
    
    if not success then
        warn("Stealth protection encountered an issue: " .. tostring(err))
    else
        print("LAJ HUB Stealth protection activated")
    end
end

-- Initialize with safer globals
_G.SpeedActive = false
_G.CurrentWalkSpeed = 16
_G.TeleportInProgress = false
_G.CharacterReady = false

StealthAntiBan()
 
-- 📌 Player Tab
local PlayerTab = Window:CreateTab("Player")  
local PlayerSection = PlayerTab:CreateSection("Player Tab")  
 
-- Store actual speed values globally
_G.ActualWalkSpeed = 16
_G.ActualJumpPower = 50

-- Stealthy Speed System
PlayerTab:CreateSlider({
    Name = "Stealth WalkSpeed",
    Range = {16, 50}, -- Lower range to stay under detection threshold
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Callback = function(value)
        _G.CurrentWalkSpeed = value -- Store in global for character respawn
        _G.SpeedActive = true -- Flag for our stealth system to apply speed
        
        -- Apply speed modestly to avoid detection
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            -- Apply the speed, but don't be too aggressive
            player.Character.Humanoid.WalkSpeed = value
        end
    end
})

-- Alternative speed system - uses velocity to move faster without changing WalkSpeed
PlayerTab:CreateSlider({
    Name = "Velocity Boost",
    Range = {0, 20}, -- Controls how much extra velocity to add
    Increment = 1,
    Suffix = "Boost",
    CurrentValue = 0,
    Callback = function(value)
        _G.VelocityBoost = value
        
        -- Use velocity to move faster without changing WalkSpeed
        if value > 0 then
            if not _G.BoostThread then
                _G.BoostThread = true
                spawn(function()
                    while _G.BoostThread and wait() do
                        local player = game.Players.LocalPlayer
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local hrp = player.Character.HumanoidRootPart
                            
                            -- Only boost when moving
                            if player.Character.Humanoid.MoveDirection.Magnitude > 0 then
                                -- Calculate modest velocity boost in move direction
                                local boost = player.Character.Humanoid.MoveDirection * _G.VelocityBoost
                                
                                -- Apply the boost gently - this is harder to detect than WalkSpeed
                                hrp.Velocity = hrp.Velocity + Vector3.new(boost.X, 0, boost.Z)
                            end
                        end
                    end
                end)
            end
        else
            _G.BoostThread = false
        end
    end
})

-- Jump Height Modifier (stealthy version)
PlayerTab:CreateSlider({
    Name = "Stealth Jump Height",
    Range = {50, 75}, -- Modest range to avoid detection
    Increment = 1,
    Suffix = "Height",
    CurrentValue = 50,
    Callback = function(value)
        -- Apply jump power in a way that's harder to detect
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.JumpPower = value
            
            -- Use a user state change - this helps avoid detection
            pcall(function()
                player.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            end)
        end
    end
})

-- Create toggle for speed system
PlayerTab:CreateToggle({
    Name = "Enable Speed Mods",
    CurrentValue = false,
    Callback = function(value)
        _G.SpeedActive = value
        
        -- When disabled, reset to default to avoid detection
        if not value and game.Players.LocalPlayer.Character and 
           game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
        end
    end
})
 
PlayerTab:CreateButton({
    Name = "Infinite Yield Admin",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    end
})
 
PlayerTab:CreateButton({
    Name = "CMD-X Admin",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source"))()
    end
})
 
PlayerTab:CreateButton({
    Name = "Nameless Admin V2",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/FilteringEnabled/NamelessAdmin/main/Source"))()
    end
})
 
-- 📌 Main Tab
local MainTab = Window:CreateTab("Main")  
local MainSection = MainTab:CreateSection("Item Teleportation")  
 
local Items = {
    "Revolver", "Sawed-off Shotgun", "Shotgun", "Rifle", "Bolt-Action Rifle",
    "Mauser", "Navy Revolver", "Crucifix", "Holy Water", "Molotov",
    "Shotgun Shells", "Rifle Ammo", "Revolver Ammo", "Turret Ammo", "Cannon Ammo",
    "Dynamite", "Helmet", "Left Shoulder Armor", "Right Shoulder Armor", "Chestplate",
    "Banjo", "Barbed Wire", "Bond", "Camera", "Coal", "Gold Bar", "Gold Cup",
    "Gold Painting", "Gold Plate", "Gold Statue", "Gold Watch", "Lantern",
    "Money Bag", "Saddle", "Sheet Metal", "Silver Bar", "Silver Cup", "Silver Painting",
    "Silver Plate", "Silver Statue", "Stone Statue", "Silver Watch", "Wooden Painting",
    "Barrel", "Book", "Chair", "Newspaper", "Rope", "Teapot", "Vase", "Wheel",
    "Bandage", "Snake Oil"
}
 
local function getNearbyItems()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return {} end
 
    local foundItems = {}
    local playerPosition = character:GetPivot().Position 
 
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and table.find(Items, obj.Name) then
            local distance = (obj:GetPivot().Position - playerPosition).Magnitude
            if distance <= 500 then
                table.insert(foundItems, obj.Name)
            end
        end
    end
 
    return foundItems
end
 
local SelectedItem = ""
local ItemDropdown = MainTab:CreateDropdown({
    Name = "Select Item to Teleport",
    Options = getNearbyItems(),
    CurrentOption = "",
    Callback = function(option)
        SelectedItem = option
    end
})
 
MainTab:CreateButton({
    Name = "Refresh Item List",
    Callback = function()
        ItemDropdown:SetOptions(getNearbyItems())
    end
})
 
-- Create alternative pathfinding-based item collection instead of teleportation
-- This approach has the player naturally walk to items rather than teleporting
local PathfindingService = game:GetService("PathfindingService")

-- Create a new "Go To Item" function that uses pathfinding instead of teleporting
local function GoToItem(target)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoidRootPart or not humanoid then return end
    
    local targetPosition = target:GetPivot().Position
    
    -- Create a path to the target
    local path = PathfindingService:CreatePath({
        AgentCanJump = true,
        AgentHeight = 5,
        AgentRadius = 2,
        WaypointSpacing = 4
    })
    
    -- Compute the path
    local success, errorMessage = pcall(function()
        path:ComputeAsync(humanoidRootPart.Position, targetPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        -- Get waypoints
        local waypoints = path:GetWaypoints()
        
        -- Create visual markers for the path (optional but helps see the path)
        local pathMarkers = {}
        for _, waypoint in ipairs(waypoints) do
            local marker = Instance.new("Part")
            marker.Shape = Enum.PartType.Ball
            marker.Material = Enum.Material.Neon
            marker.Size = Vector3.new(0.5, 0.5, 0.5)
            marker.Position = waypoint.Position
            marker.Anchored = true
            marker.CanCollide = false
            marker.Parent = workspace
            marker.Transparency = 0.7
            
            -- Auto-delete after some time
            spawn(function()
                wait(5)
                marker:Destroy()
            end)
            
            table.insert(pathMarkers, marker)
        end
        
        -- Start moving to the target by following each waypoint
        _G.CurrentlyMoving = true
        
        -- Use actual Humanoid pathfinding to reach the target
        -- This looks much more natural to anti-cheat systems
        for i, waypoint in ipairs(waypoints) do
            if not _G.CurrentlyMoving then break end
            
            -- Move to this waypoint
            humanoid:MoveTo(waypoint.Position)
            
            -- Wait until humanoid reaches waypoint or timeout
            local reachedWaypoint = false
            local startTime = tick()
            
            while not reachedWaypoint and _G.CurrentlyMoving do
                -- Check if waypoint reached
                local distance = (humanoidRootPart.Position - waypoint.Position).Magnitude
                if distance < 3 then
                    reachedWaypoint = true
                end
                
                -- Timeout after 2 seconds per waypoint
                if tick() - startTime > 2 then
                    reachedWaypoint = true
                end
                
                wait()
            end
            
            -- If this waypoint requires jumping
            if waypoint.Action == Enum.PathWaypointAction.Jump then
                humanoid.Jump = true
            end
        end
        
        -- Clean up
        _G.CurrentlyMoving = false
    else
        -- Path failed, try direct movement
        humanoid:MoveTo(targetPosition)
        
        -- Display a marker so we can see where we're trying to go
        local marker = Instance.new("Part")
        marker.Shape = Enum.PartType.Ball
        marker.Material = Enum.Material.Neon
        marker.Size = Vector3.new(1, 1, 1)
        marker.Position = targetPosition
        marker.Anchored = true
        marker.CanCollide = false
        marker.Parent = workspace
        marker.Transparency = 0.5
        marker.Color = Color3.fromRGB(255, 0, 0) -- Red for failed path
        
        -- Auto-delete after some time
        spawn(function()
            wait(3)
            marker:Destroy()
        end)
    end
end

-- Keep original teleport function for reference but don't use it
local function UnsafeTeleport(target)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    humanoidRootPart.CFrame = target:GetPivot()
end
 
-- Add a cancel button for pathfinding
MainTab:CreateButton({
    Name = "Cancel Movement",
    Callback = function()
        _G.CurrentlyMoving = false
    end
})

-- Change teleport buttons to use our new safe pathfinding method
MainTab:CreateButton({
    Name = "Walk to Item (Safe)",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and SelectedItem ~= "" then
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name == SelectedItem then
                    GoToItem(obj)
                    break
                end
            end
        end
    end
})
 
MainTab:CreateButton({
    Name = "Walk to All Items (Safe)",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            -- Instead of teleporting to all items at once, set up a queue
            local itemQueue = {}
            
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and table.find(Items, obj.Name) then
                    table.insert(itemQueue, obj)
                end
            end
            
            -- Sort by distance to prioritize closest items
            table.sort(itemQueue, function(a, b)
                local aDistance = (a:GetPivot().Position - character:GetPivot().Position).Magnitude
                local bDistance = (b:GetPivot().Position - character:GetPivot().Position).Magnitude
                return aDistance < bDistance
            end)
            
            -- Start a thread to process the queue one by one
            spawn(function()
                for _, item in ipairs(itemQueue) do
                    -- Check if we should continue
                    if not _G.CurrentlyMoving then
                        GoToItem(item)
                        -- Wait until we reach the item or timeout
                        local startTime = tick()
                        while _G.CurrentlyMoving and tick() - startTime < 10 do
                            wait(0.1)
                        end
                    else
                        -- Wait until previous movement is complete
                        while _G.CurrentlyMoving do
                            wait(0.5)
                        end
                        GoToItem(item)
                    end
                end
            end)
        end
    end
})

-- Add legacy teleport options (but with warning)
MainTab:CreateButton({
    Name = "⚠️ Teleport to Item (Ban Risk)",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and SelectedItem ~= "" then
            -- Show warning notification
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Ban Risk",
                Text = "This method may get you banned. Use walk method instead.",
                Duration = 3
            })
            
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name == SelectedItem then
                    UnsafeTeleport(obj)
                    break
                end
            end
        end
    end
})
