---date
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
 
local Window = Rayfield:CreateWindow({
    Name = "LAJ HUBss | Dead Rails [BETA] ",
    LoadingTitle = "LAJ HUB | Loading...",
    LoadingSubtitle = "Please wait...",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnityNexus_Config"
    }
})
 
-- 🛡️ Advanced Anti-Ban & Anti-Detection System with Position Reversion Bypass
local function AdvancedAntiBan()
    local success, err = pcall(function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local RunService = game:GetService("RunService")
        local PhysicsService = game:GetService("PhysicsService")
        local NetworkSettings = settings():GetService("NetworkSettings")
        
        -- Store the original position for the reversion system
        _G.LastPosition = nil
        _G.PositionBypass = true
        
        -- Force extreme network settings to ensure control
        NetworkSettings.IncomingReplicationLag = 0
        sethiddenproperty(game, "MaxChannelCount", 999999)
        
        -- 1. Network Ownership Bypass - More aggressive to combat position reversion
        for i = 1, 3 do -- Apply multiple times to ensure it takes effect
            sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
            sethiddenproperty(LocalPlayer, "MaximumSimulationRadius", math.huge)
            sethiddenproperty(LocalPlayer, "PreSimulationRadius", math.huge)
        end
        
        -- 2. Aggressive Physics Network Ownership
        spawn(function()
            while wait(0.5) do
                -- Continuously claim network ownership of all physics parts
                sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                
                for _, part in pairs(workspace:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if not part:IsGrounded() then
                            part.Massless = true
                            part.CanCollide = false
                            part.Anchored = false
                            
                            if part:IsDescendantOf(LocalPlayer.Character) then
                                part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                            end
                        end
                    end
                end
            end
        end)
        
        -- 3. Anti-Cheat Remote Block - More comprehensive to catch all reversion attempts
        local oldNamecall = nil
        oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            
            -- More extensive checking to block hidden remotes and network reversion events
            if (method == "FireServer" or method == "InvokeServer") and typeof(self) == "Instance" then
                local name = string.lower(tostring(self.Name))
                
                -- Expanded list of keywords to block
                if name:find("detect") or name:find("cheat") or name:find("ban") or 
                   name:find("kick") or name:find("report") or name:find("violation") or
                   name:find("check") or name:find("secure") or name:find("warp") or
                   name:find("teleport") or name:find("position") or name:find("revert") or 
                   name:find("security") or name:find("verify") or name:find("validate") then
                    return nil
                end
                
                -- Block position reversion attempts
                if method == "FireServer" then
                    for _, arg in pairs(args) do
                        if typeof(arg) == "Vector3" or typeof(arg) == "CFrame" then
                            if _G.LastPosition and LocalPlayer.Character and 
                               LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                return nil -- Block position sync events
                            end
                        end
                    end
                end
            end
            
            return oldNamecall(self, ...)
        end)
        
        -- 4. Position Reversion Prevention
        -- Track and restore position if the server tries to reset it
        RunService.Heartbeat:Connect(function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and _G.PositionBypass then
                local hrp = LocalPlayer.Character.HumanoidRootPart
                
                if _G.LastPosition then
                    -- Detect position reversion attempts (sudden large changes)
                    if (hrp.Position - _G.LastPosition).Magnitude > 5 and 
                       not _G.IsTeleporting and not _G.IsChangingSpeed then
                        -- Server tried to revert us - force our position back
                        hrp.CFrame = CFrame.new(_G.LastPosition)
                    end
                end
                
                -- Update our last known good position
                _G.LastPosition = hrp.Position
            end
        end)
        
        -- 5. Enhanced Humanoid Property Spoofer
        local oldIndex = nil
        oldIndex = hookmetamethod(game, "__index", function(self, key)
            -- Spoof properties to appear legitimate to server checks
            if not checkcaller() and LocalPlayer.Character and 
               self:IsDescendantOf(LocalPlayer.Character) then
                if key == "WalkSpeed" or key == "walkSpeed" then
                    return 16 -- Default walk speed
                elseif key == "JumpPower" or key == "jumpPower" then
                    return 50 -- Default jump power
                elseif key == "HipHeight" then
                    return 0 -- Default hip height
                elseif key == "Health" then
                    -- Return a high value to prevent death from anti-cheat
                    return 100
                end
            end
            return oldIndex(self, key)
        end)
        
        -- 6. Prevent anti-cheat from modifying character properties
        local oldNewIndex = nil
        oldNewIndex = hookmetamethod(game, "__newindex", function(self, key, value)
            -- Block all attempts to modify our character properties by the server
            if not checkcaller() and LocalPlayer.Character and self:IsDescendantOf(LocalPlayer.Character) then
                -- Block server-side speed/position changes
                if key == "WalkSpeed" or key == "JumpPower" or 
                   key == "CFrame" or key == "Position" or
                   key == "Velocity" or key == "RotVelocity" then
                    if not _G.IsTeleporting and not _G.IsChangingSpeed then
                        return -- Block the change
                    end
                end
            end
            return oldNewIndex(self, key, value)
        end)
        
        -- 7. Comprehensive Anti-Kick/Ban System
        -- Hook multiple functions that could be used to kick or ban
        local oldKick = LocalPlayer.Kick
        LocalPlayer.Kick = function() return end
        
        hookfunction(LocalPlayer.Kick, function() return wait(9e9) end) 
        hookfunction(LocalPlayer.kick, function() return wait(9e9) end)
        
        local oldDestroy = game.Destroy
        hookfunction(game.Destroy, function(self, ...)
            if self == LocalPlayer then return wait(9e9) end
            return oldDestroy(self, ...)
        end)
        
        -- 8. Aggressive Character Protection on Respawn
        LocalPlayer.CharacterAdded:Connect(function(character)
            task.wait(0.2) -- Wait for character to fully load
            
            -- Reset tracking
            _G.LastPosition = nil
            
            -- Apply extreme network settings for new character
            sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
            sethiddenproperty(LocalPlayer, "MaximumSimulationRadius", math.huge)
            sethiddenproperty(LocalPlayer, "PreSimulationRadius", math.huge)
            
            -- Protect the new character
            if character:FindFirstChild("Humanoid") then
                -- Make it appear standard initially
                local humanoid = character:FindFirstChild("Humanoid")
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
                
                -- Apply invulnerability
                humanoid.BreakJointsOnDeath = false
                humanoid.RequiresNeck = false
                
                wait(1) -- Give anti-cheat time to approve character
                
                -- Now restore our custom values to the new character
                if _G.ActualWalkSpeed then
                    humanoid.WalkSpeed = _G.ActualWalkSpeed
                end
                
                if _G.ActualJumpPower then
                    humanoid.JumpPower = _G.ActualJumpPower
                end
            end
        end)
        
        -- 9. Advanced Anti-Detection Cleaning System
        spawn(function()
            while wait(2) do -- Run more frequently
                if LocalPlayer.Character then
                    -- Destroy anti-cheat scripts
                    for _, v in pairs(LocalPlayer.Character:GetDescendants()) do
                        local lowerName = string.lower(v.Name)
                        if v:IsA("Script") or v:IsA("LocalScript") then
                            if lowerName:find("anti") or lowerName:find("detect") or 
                               lowerName:find("check") or lowerName:find("secure") or
                               lowerName:find("warp") or lowerName:find("verif") then
                                v:Destroy()
                            end
                        end
                    end
                    
                    -- Disable monitoring connections
                    for _, connection in pairs(getconnections(LocalPlayer.Character.ChildAdded)) do
                        connection:Disable()
                    end
                    
                    for _, connection in pairs(getconnections(RunService.Stepped)) do
                        if not connection.Function or not debug.info(connection.Function, "s") then
                            connection:Disable()
                        end
                    end
                    
                    -- Clean teleport history
                    game:GetService("TeleportService"):SetTeleportGui(nil)
                    
                    -- Refresh network ownership
                    sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                end
            end
        end)
    end)
    
    if not success then
        warn("Enhanced Anti-Ban system encountered a minor issue: " .. tostring(err))
    else
        print("LAJ HUB Ultimate Anti-Ban system activated successfully")
    end
end

-- Initialize global variables for teleport/speed change tracking
_G.IsTeleporting = false
_G.IsChangingSpeed = false

AdvancedAntiBan()
 
-- 📌 Player Tab
local PlayerTab = Window:CreateTab("Player")  
local PlayerSection = PlayerTab:CreateSection("Player Tab")  
 
-- Store actual speed values globally
_G.ActualWalkSpeed = 16
_G.ActualJumpPower = 50

-- Undetectable speed slider
PlayerTab:CreateSlider({
    Name = "Safe WalkSpeed",
    Range = {16, 150},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Callback = function(value)
        _G.ActualWalkSpeed = value
        
        -- Apply speed in a way that avoids detection
        if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            -- Using a separate thread for continuous updates to avoid detection patterns
            if not _G.SpeedUpdateThread then
                _G.SpeedUpdateThread = true
                spawn(function()
                    while _G.SpeedUpdateThread and wait() do
                        -- Check if character still exists
                        if game.Players.LocalPlayer.Character and 
                           game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
                            -- Apply speed but make it look natural to anti-cheat
                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = _G.ActualWalkSpeed
                        end
                    end
                end)
            end
        end
    end
})
 
-- Undetectable jump power slider
PlayerTab:CreateSlider({
    Name = "Safe JumpPower",
    Range = {50, 200},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = 50,
    Callback = function(value)
        _G.ActualJumpPower = value
        
        -- Apply jump power in a way that avoids detection
        if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            -- Using a separate thread for continuous updates
            if not _G.JumpUpdateThread then
                _G.JumpUpdateThread = true
                spawn(function()
                    while _G.JumpUpdateThread and wait() do
                        -- Check if character still exists
                        if game.Players.LocalPlayer.Character and 
                           game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
                            -- Apply jump power but make it look natural to anti-cheat
                            game.Players.LocalPlayer.Character.Humanoid.JumpPower = _G.ActualJumpPower
                        end
                    end
                end)
            end
        end
    end
})

-- Original speed (for reference)
PlayerTab:CreateSlider({
    Name = "High Risk WalkSpeed",
    Range = {16, 300},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Callback = function(value)
        if game.Players.LocalPlayer.Character then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = value
        end
    end
})
 
-- Original jump power (for reference)
PlayerTab:CreateSlider({
    Name = "High Risk JumpPower",
    Range = {50, 500},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = 50,
    Callback = function(value)
        if game.Players.LocalPlayer.Character then
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = value
        end
    end
})
 
PlayerTab:CreateButton({
    Name = "Infinite Yield Admin",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    end
})
 
PlayerTab:CreateButton({
    Name = "CMD-X Admin",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source"))()
    end
})
 
PlayerTab:CreateButton({
    Name = "Nameless Admin V2",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/FilteringEnabled/NamelessAdmin/main/Source"))()
    end
})
 
-- 📌 Main Tab
local MainTab = Window:CreateTab("Main")  
local MainSection = MainTab:CreateSection("Item Teleportation")  
 
local Items = {
    "Revolver", "Sawed-off Shotgun", "Shotgun", "Rifle", "Bolt-Action Rifle",
    "Mauser", "Navy Revolver", "Crucifix", "Holy Water", "Molotov",
    "Shotgun Shells", "Rifle Ammo", "Revolver Ammo", "Turret Ammo", "Cannon Ammo",
    "Dynamite", "Helmet", "Left Shoulder Armor", "Right Shoulder Armor", "Chestplate",
    "Banjo", "Barbed Wire", "Bond", "Camera", "Coal", "Gold Bar", "Gold Cup",
    "Gold Painting", "Gold Plate", "Gold Statue", "Gold Watch", "Lantern",
    "Money Bag", "Saddle", "Sheet Metal", "Silver Bar", "Silver Cup", "Silver Painting",
    "Silver Plate", "Silver Statue", "Stone Statue", "Silver Watch", "Wooden Painting",
    "Barrel", "Book", "Chair", "Newspaper", "Rope", "Teapot", "Vase", "Wheel",
    "Bandage", "Snake Oil"
}
 
local function getNearbyItems()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return {} end
 
    local foundItems = {}
    local playerPosition = character:GetPivot().Position 
 
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and table.find(Items, obj.Name) then
            local distance = (obj:GetPivot().Position - playerPosition).Magnitude
            if distance <= 500 then
                table.insert(foundItems, obj.Name)
            end
        end
    end
 
    return foundItems
end
 
local SelectedItem = ""
local ItemDropdown = MainTab:CreateDropdown({
    Name = "Select Item to Teleport",
    Options = getNearbyItems(),
    CurrentOption = "",
    Callback = function(option)
        SelectedItem = option
    end
})
 
MainTab:CreateButton({
    Name = "Refresh Item List",
    Callback = function()
        ItemDropdown:SetOptions(getNearbyItems())
    end
})
 
-- 🛡️ Safe Teleportation (Avoids Instant Ban)
-- Force teleport that bypasses position reversion
local function SafeTeleport(target)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoidRootPart or not humanoid then return end
    
    local targetPosition = target:GetPivot().Position
    local startPosition = humanoidRootPart.Position
    local distance = (targetPosition - startPosition).Magnitude
    
    -- Flag that we're teleporting to prevent position reversion
    _G.IsTeleporting = true
    
    -- For extremely short distances, just do it directly
    if distance < 5 then
        humanoidRootPart.CFrame = target:GetPivot()
        task.wait(0.1)
        _G.IsTeleporting = false
        _G.LastPosition = targetPosition -- Update last position to prevent reversion
        return
    end
    
    -- For longer distances, use network-manipulating teleport
    -- First, maximize network ownership
    for i = 1, 3 do
        sethiddenproperty(player, "SimulationRadius", math.huge)
        sethiddenproperty(player, "MaximumSimulationRadius", math.huge)
    end
    
    -- Create steps but with network pausing between them
    local steps = math.min(20, math.ceil(distance / 10))
    for i = 1, steps do
        if not character or not humanoidRootPart then
            _G.IsTeleporting = false
            return
        end
        
        -- Calculate the next position
        local progress = i / steps
        local newPosition = startPosition:Lerp(targetPosition, progress)
        
        -- Use a system that's harder to detect
        humanoidRootPart.Anchored = true -- Anchor to prevent physics reversion
        humanoidRootPart.CFrame = CFrame.new(newPosition)
        task.wait() -- Wait one frame for physics to update
        humanoidRootPart.Anchored = false -- Unanchor to allow movement again
        
        -- Network manipulation to prevent detection
        if i % 3 == 0 then -- Every few steps
            -- Force character to acknowledge the new position
            humanoid:ChangeState(Enum.HumanoidStateType.Physics)
            task.wait()
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            task.wait()
            
            -- Update our last position in the anti-reversion system
            _G.LastPosition = humanoidRootPart.Position
        end
        
        task.wait(0.01) -- Shorter wait between steps
    end
    
    -- Final positioning with extra force
    if character and humanoidRootPart then
        -- Use all three methods for maximum effect
        humanoidRootPart.Anchored = true
        humanoidRootPart.CFrame = target:GetPivot()
        task.wait(0.05)
        humanoidRootPart.Anchored = false
        humanoid:ChangeState(Enum.HumanoidStateType.Landed)
    end
    
    -- Update position tracking
    task.wait(0.1)
    _G.LastPosition = targetPosition
    _G.IsTeleporting = false
end
 
MainTab:CreateButton({
    Name = "Teleport to Item",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and SelectedItem ~= "" then
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name == SelectedItem then
                    SafeTeleport(obj)
                    break
                end
            end
        end
    end
})
 
MainTab:CreateButton({
    Name = "Teleport to All Items",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and table.find(Items, obj.Name) then
                    SafeTeleport(obj)
                    task.wait(0.5) -- Small delay for safety
                end
            end
        end
    end
})
