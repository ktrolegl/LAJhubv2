---date 
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
 
local Window = Rayfield:CreateWindow({
    Name = "LAJ HUBs | Dead Rails [BETA] ",
    LoadingTitle = "LAJ HUB | Loading...",
    LoadingSubtitle = "Please wait...",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "UnityNexus_Config"
    }
})
 
-- 🛡️ Stealth Anti-Ban & Anti-Detection System
local function StealthAntiBan()
    local success, err = pcall(function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local RunService = game:GetService("RunService")
        
        -- Reset any previous state
        _G.OriginalMethods = {}
        _G.Protected = true
        
        -- 1. Low-profile Anti-Detection
        -- Instead of huge values, use slightly increased values that don't trigger detection
        sethiddenproperty(LocalPlayer, "SimulationRadius", 30)
        sethiddenproperty(LocalPlayer, "MaximumSimulationRadius", 35)
        
        -- 2. Advanced Anti-Kick/Ban (Silent version)
        -- Store original methods to avoid detection
        _G.OriginalMethods.Kick = LocalPlayer.Kick
        _G.OriginalMethods.kick = LocalPlayer.kick
        
        -- Silently replace kick methods
        hookfunction(LocalPlayer.Kick, function(...)
            print("Kick attempted - blocked")
            return wait(9e9)
        end)
        
        -- 3. Basic Remote Detection Block (Hidden approach)
        local mt = getrawmetatable(game)
        local oldNamecall = mt.__namecall
        setreadonly(mt, false)
        
        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if method == "FireServer" or method == "InvokeServer" then
                -- Only block specific anti-cheat remotes we've identified
                local name = self.Name and string.lower(self.Name) or ""
                
                -- Known anti-cheat remote patterns in Dead Rails
                if name:find("security") or name:find("anti") or
                   name:find("check") or name:find("detect") then
                    return nil
                end
                
                -- If it's teleporting someone, let it pass but monitor it
                if method == "FireServer" and #args > 0 then
                    for _, arg in pairs(args) do
                        if typeof(arg) == "CFrame" and _G.TeleportInProgress then
                            -- This is likely our teleport, let it through
                            return oldNamecall(self, ...)
                        end
                    end
                end
            end
            
            return oldNamecall(self, ...)
        end)
        
        setreadonly(mt, true)
        
        -- 4. Silent Character Protection
        -- This avoids detection by being selective about what we modify
        RunService.Heartbeat:Connect(function()
            if not LocalPlayer.Character then return end
            
            -- Subtle network manipulation (less detectable)
            pcall(function()
                sethiddenproperty(LocalPlayer, "SimulationRadius", 30)
            end)
            
            -- Only apply speed if we requested it
            if LocalPlayer.Character:FindFirstChild("Humanoid") and _G.SpeedActive then
                LocalPlayer.Character.Humanoid.WalkSpeed = _G.CurrentWalkSpeed or 16
            end
        end)
        
        -- 5. Character Added Protection (Quiet version)
        LocalPlayer.CharacterAdded:Connect(function(character)
            wait(1) -- Wait for anti-cheat to finish its checks
            
            if character:FindFirstChild("Humanoid") then
                -- This flag indicates we can safely modify the character
                _G.CharacterReady = true
                
                -- If we had custom speed before, restore it
                if _G.CurrentWalkSpeed and _G.SpeedActive then
                    character.Humanoid.WalkSpeed = _G.CurrentWalkSpeed
                end
            end
        end)
        
        -- 6. Periodic Silent Cleanup (Minimal detection footprint)
        spawn(function()
            while wait(10) do
                if LocalPlayer.Character then
                    -- Only remove obvious anti-cheat scripts
                    for _, v in pairs(LocalPlayer.Character:GetDescendants()) do
                        if v:IsA("Script") and v.Name:lower():find("detect") then
                            -- Instead of destroying, disable it to avoid detection
                            pcall(function()
                                v.Disabled = true
                            end)
                        end
                    end
                end
            end
        end)
    end)
    
    if not success then
        warn("Stealth protection encountered an issue: " .. tostring(err))
    else
        print("LAJ HUB Stealth protection activated")
    end
end

-- Initialize with safer globals
_G.SpeedActive = false
_G.CurrentWalkSpeed = 16
_G.TeleportInProgress = false
_G.CharacterReady = false

StealthAntiBan()
 
-- 📌 Player Tab
local PlayerTab = Window:CreateTab("Player")  
local PlayerSection = PlayerTab:CreateSection("Player Tab")  
 
-- Store actual speed values globally
_G.ActualWalkSpeed = 16
_G.ActualJumpPower = 50

-- Stealthy Speed System
PlayerTab:CreateSlider({
    Name = "Stealth WalkSpeed",
    Range = {16, 50}, -- Lower range to stay under detection threshold
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Callback = function(value)
        _G.CurrentWalkSpeed = value -- Store in global for character respawn
        _G.SpeedActive = true -- Flag for our stealth system to apply speed
        
        -- Apply speed modestly to avoid detection
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            -- Apply the speed, but don't be too aggressive
            player.Character.Humanoid.WalkSpeed = value
        end
    end
})

-- Alternative speed system - uses velocity to move faster without changing WalkSpeed
PlayerTab:CreateSlider({
    Name = "Velocity Boost",
    Range = {0, 20}, -- Controls how much extra velocity to add
    Increment = 1,
    Suffix = "Boost",
    CurrentValue = 0,
    Callback = function(value)
        _G.VelocityBoost = value
        
        -- Use velocity to move faster without changing WalkSpeed
        if value > 0 then
            if not _G.BoostThread then
                _G.BoostThread = true
                spawn(function()
                    while _G.BoostThread and wait() do
                        local player = game.Players.LocalPlayer
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local hrp = player.Character.HumanoidRootPart
                            
                            -- Only boost when moving
                            if player.Character.Humanoid.MoveDirection.Magnitude > 0 then
                                -- Calculate modest velocity boost in move direction
                                local boost = player.Character.Humanoid.MoveDirection * _G.VelocityBoost
                                
                                -- Apply the boost gently - this is harder to detect than WalkSpeed
                                hrp.Velocity = hrp.Velocity + Vector3.new(boost.X, 0, boost.Z)
                            end
                        end
                    end
                end)
            end
        else
            _G.BoostThread = false
        end
    end
})

-- Jump Height Modifier (stealthy version)
PlayerTab:CreateSlider({
    Name = "Stealth Jump Height",
    Range = {50, 75}, -- Modest range to avoid detection
    Increment = 1,
    Suffix = "Height",
    CurrentValue = 50,
    Callback = function(value)
        -- Apply jump power in a way that's harder to detect
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.JumpPower = value
            
            -- Use a user state change - this helps avoid detection
            pcall(function()
                player.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            end)
        end
    end
})

-- Create toggle for speed system
PlayerTab:CreateToggle({
    Name = "Enable Speed Mods",
    CurrentValue = false,
    Callback = function(value)
        _G.SpeedActive = value
        
        -- When disabled, reset to default to avoid detection
        if not value and game.Players.LocalPlayer.Character and 
           game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
        end
    end
})
 
PlayerTab:CreateButton({
    Name = "Infinite Yield Admin",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    end
})
 
PlayerTab:CreateButton({
    Name = "CMD-X Admin",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source"))()
    end
})
 
PlayerTab:CreateButton({
    Name = "Nameless Admin V2",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/FilteringEnabled/NamelessAdmin/main/Source"))()
    end
})
 
-- 📌 Main Tab
local MainTab = Window:CreateTab("Main")  
local MainSection = MainTab:CreateSection("Item Teleportation")  
 
local Items = {
    "Revolver", "Sawed-off Shotgun", "Shotgun", "Rifle", "Bolt-Action Rifle",
    "Mauser", "Navy Revolver", "Crucifix", "Holy Water", "Molotov",
    "Shotgun Shells", "Rifle Ammo", "Revolver Ammo", "Turret Ammo", "Cannon Ammo",
    "Dynamite", "Helmet", "Left Shoulder Armor", "Right Shoulder Armor", "Chestplate",
    "Banjo", "Barbed Wire", "Bond", "Camera", "Coal", "Gold Bar", "Gold Cup",
    "Gold Painting", "Gold Plate", "Gold Statue", "Gold Watch", "Lantern",
    "Money Bag", "Saddle", "Sheet Metal", "Silver Bar", "Silver Cup", "Silver Painting",
    "Silver Plate", "Silver Statue", "Stone Statue", "Silver Watch", "Wooden Painting",
    "Barrel", "Book", "Chair", "Newspaper", "Rope", "Teapot", "Vase", "Wheel",
    "Bandage", "Snake Oil"
}
 
local function getNearbyItems()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return {} end
 
    local foundItems = {}
    local playerPosition = character:GetPivot().Position 
 
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and table.find(Items, obj.Name) then
            local distance = (obj:GetPivot().Position - playerPosition).Magnitude
            if distance <= 500 then
                table.insert(foundItems, obj.Name)
            end
        end
    end
 
    return foundItems
end
 
local SelectedItem = ""
local ItemDropdown = MainTab:CreateDropdown({
    Name = "Select Item to Teleport",
    Options = getNearbyItems(),
    CurrentOption = "",
    Callback = function(option)
        SelectedItem = option
    end
})
 
MainTab:CreateButton({
    Name = "Refresh Item List",
    Callback = function()
        ItemDropdown:SetOptions(getNearbyItems())
    end
})
 
-- Create Item ESP system instead of movement-based collection
-- This will highlight items so you can find them naturally

-- Container for all visual elements
local ESPFolder = Instance.new("Folder")
ESPFolder.Name = "LAJ_ItemESP"
ESPFolder.Parent = game.CoreGui

-- Create a BillboardGui with item name and distance
local function CreateItemESP(item, colorOverride)
    -- Check if ESP already exists for this item
    for _, existing in pairs(ESPFolder:GetChildren()) do
        if existing.Name == "ESP_" .. item.Name .. "_" .. tostring(item:GetFullName():len()) then
            return existing -- ESP already exists
        end
    end
    
    -- Create unique identifier for this ESP
    local espName = "ESP_" .. item.Name .. "_" .. tostring(item:GetFullName():len())
    
    -- Create the ESP container
    local espContainer = Instance.new("Folder")
    espContainer.Name = espName
    espContainer.Parent = ESPFolder
    
    -- Determine color based on item type
    local color
    if colorOverride then
        color = colorOverride
    else
        -- Different colors for different item types
        if item.Name:find("Gold") then
            color = Color3.fromRGB(255, 215, 0) -- Gold
        elseif item.Name:find("Silver") then
            color = Color3.fromRGB(192, 192, 192) -- Silver
        elseif item.Name:find("Rifle") or item.Name:find("Shotgun") or item.Name:find("Revolver") then
            color = Color3.fromRGB(255, 0, 0) -- Red for weapons
        elseif item.Name:find("Ammo") then
            color = Color3.fromRGB(255, 128, 0) -- Orange for ammo
        elseif item.Name:find("Armor") or item.Name:find("Helmet") or item.Name:find("Chestplate") then
            color = Color3.fromRGB(0, 0, 255) -- Blue for armor
        else
            color = Color3.fromRGB(255, 255, 255) -- White for others
        end
    end
    
    -- Create billboardgui for the label
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "ESPLabel"
    billboardGui.AlwaysOnTop = true
    billboardGui.Size = UDim2.new(0, 200, 0, 50)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.Adornee = item
    billboardGui.Parent = espContainer
    
    -- Create text label for item name
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "ItemName"
    nameLabel.Size = UDim2.new(1, 0, 0, 20)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = color
    nameLabel.Text = item.Name
    nameLabel.TextSize = 18
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.TextStrokeTransparency = 0.3
    nameLabel.Parent = billboardGui
    
    -- Create text label for distance
    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Name = "Distance"
    distanceLabel.Size = UDim2.new(1, 0, 0, 20)
    distanceLabel.Position = UDim2.new(0, 0, 0, 20)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    distanceLabel.TextSize = 14
    distanceLabel.Font = Enum.Font.SourceSans
    distanceLabel.TextStrokeTransparency = 0.5
    distanceLabel.Parent = billboardGui
    
    -- Create highlight
    local highlight = Instance.new("Highlight")
    highlight.FillColor = color
    highlight.OutlineColor = Color3.new(1, 1, 1)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Adornee = item
    highlight.Parent = espContainer
    
    -- Create beam pointer (line pointing to the item)
    local attachment0 = Instance.new("Attachment")
    attachment0.Name = "BeamAttachment0"
    attachment0.Parent = workspace.Terrain
    
    local attachment1 = Instance.new("Attachment")
    attachment1.Name = "BeamAttachment1"
    attachment1.Parent = item
    
    local beam = Instance.new("Beam")
    beam.Name = "PointerBeam"
    beam.Color = ColorSequence.new(color)
    beam.Transparency = NumberSequence.new(0.4)
    beam.Width0 = 0.2
    beam.Width1 = 0.2
    beam.FaceCamera = true
    beam.Attachment0 = attachment0
    beam.Attachment1 = attachment1
    beam.Parent = espContainer
    
    -- Update the distance label and beam position
    spawn(function()
        while espContainer.Parent == ESPFolder do
            wait(0.1) -- Update 10 times per second
            
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and item.Parent then
                local distance = (item:GetPivot().Position - player.Character.HumanoidRootPart.Position).Magnitude
                distanceLabel.Text = math.floor(distance) .. " studs"
                
                -- Update beam starting position
                attachment0.WorldPosition = player.Character.HumanoidRootPart.Position + Vector3.new(0, 1, 0)
                
                -- Color code by distance
                if distance < 30 then
                    distanceLabel.TextColor3 = Color3.fromRGB(0, 255, 0) -- Green when close
                elseif distance < 100 then
                    distanceLabel.TextColor3 = Color3.fromRGB(255, 255, 0) -- Yellow when medium distance
                else
                    distanceLabel.TextColor3 = Color3.fromRGB(255, 0, 0) -- Red when far
                end
                
                -- Make ESP elements more visible when closer
                local visibilityMultiplier = math.clamp(1 - (distance / 300), 0.3, 1)
                nameLabel.TextTransparency = 1 - visibilityMultiplier
                distanceLabel.TextTransparency = 1 - visibilityMultiplier
                highlight.FillTransparency = 0.5 + (0.5 * (1 - visibilityMultiplier))
                beam.Transparency = NumberSequence.new(0.4 + (0.6 * (1 - visibilityMultiplier)))
            else
                -- Character or item no longer exists
                espContainer:Destroy()
                break
            end
        end
    end)
    
    return espContainer
end

-- Function to clear all ESP
local function ClearAllESP()
    for _, child in pairs(ESPFolder:GetChildren()) do
        child:Destroy()
    end
end

-- Ultra-fast teleportation that happens before anti-cheat can respond
local function InstantTeleport(target)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    -- Store original position for safety
    local originalPosition = character.HumanoidRootPart.CFrame
    
    -- Set up event hooks to prevent position reversion
    local RunService = game:GetService("RunService")
    local heartbeatConn
    
    -- Rapidly teleport back and forth several times, too fast for anti-cheat to catch
    local targetCFrame = target:GetPivot()
    
    -- Simulate network lag by freezing all physics temporarily
    local physicsSettings = settings().Physics
    local originalPhysicsSteppingMethod = physicsSettings.PhysicsSteppingMethod
    
    -- Disable physics simulation temporarily
    physicsSettings.PhysicsSteppingMethod = Enum.PhysicsSteppingMethod.Fixed
    
    -- Extreme teleport sequence
    character.HumanoidRootPart.Anchored = true  -- Anchor to prevent physics
    
    -- This happens too fast for server to respond
    RunService.Heartbeat:Wait()
    character.HumanoidRootPart.CFrame = targetCFrame
    RunService.Heartbeat:Wait()
    
    -- Unanchor immediately after teleport
    character.HumanoidRootPart.Anchored = false

    -- Restore physics
    physicsSettings.PhysicsSteppingMethod = originalPhysicsSteppingMethod
end

-- Function to flash teleport to every item and back instantly to collect them all
local function FlashCollectItems()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    -- Store original position
    local originalPosition = character.HumanoidRootPart.CFrame
    
    -- Find all nearby items
    local itemsToCollect = {}
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and table.find(Items, obj.Name) then
            local distance = (obj:GetPivot().Position - originalPosition.Position).Magnitude
            if distance <= 100 then
                table.insert(itemsToCollect, obj)
            end
        end
    end
    
    -- Sort by distance
    table.sort(itemsToCollect, function(a, b)
        local aDistance = (a:GetPivot().Position - originalPosition.Position).Magnitude
        local bDistance = (b:GetPivot().Position - originalPosition.Position).Magnitude
        return aDistance < bDistance
    end)
    
    -- Notify about collection attempt
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Flash Collection",
        Text = "Attempting to flash collect " .. #itemsToCollect .. " items...",
        Duration = 3
    })
    
    -- Collect items with ultra fast teleports
    for i, item in ipairs(itemsToCollect) do
        if item and item.Parent then
            InstantTeleport(item)
            task.wait(0.01) -- Ultra small delay between teleports
        end
    end
    
    -- Return to original position
    task.wait(0.05)
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = originalPosition
    end
end

-- Function to get items near the player with visual indicators
local function ShowNearbyItems(maxDistance)
    maxDistance = maxDistance or 100 -- Default to 100 studs if not specified
    
    -- Clear previous ESPs first
    ClearAllESP()
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local foundItems = {}
    local foundCount = 0
    local playerPosition = character:GetPivot().Position 
    
    -- Find and highlight items
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and table.find(Items, obj.Name) then
            local distance = (obj:GetPivot().Position - playerPosition).Magnitude
            if distance <= maxDistance then
                foundCount = foundCount + 1
                CreateItemESP(obj)
                table.insert(foundItems, obj.Name)
            end
        end
    end
    
    -- Notify the player
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Items Found",
        Text = foundCount .. " items highlighted within " .. maxDistance .. " studs",
        Duration = 5
    })
    
    return foundItems
end
 
-- Show ESP for items instead of trying to walk to them
-- This is our main approach - shows items without teleporting
MainTab:CreateButton({
    Name = "Show Nearby Items (50 studs)",
    Callback = function()
        ShowNearbyItems(50)
    end
})

MainTab:CreateButton({
    Name = "Show Nearby Items (100 studs)",
    Callback = function()
        ShowNearbyItems(100)
    end
})

MainTab:CreateButton({
    Name = "Show Nearby Items (200 studs)",
    Callback = function()
        ShowNearbyItems(200)
    end
})

MainTab:CreateButton({
    Name = "Clear Item ESP",
    Callback = function()
        ClearAllESP()
    end
})

-- Ultra-fast flash teleport (our new approach)
MainTab:CreateButton({
    Name = "⚡ Flash Collect Nearby Items",
    Callback = function()
        FlashCollectItems()
    end
})

-- Single item flash teleport
MainTab:CreateButton({
    Name = "⚡ Flash to Selected Item",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and SelectedItem ~= "" then
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name == SelectedItem then
                    -- Store original position
                    local originalPosition = character.HumanoidRootPart.CFrame
                    
                    -- Flash to item and back
                    InstantTeleport(obj)
                    task.wait(0.03)
                    
                    -- Flash back to original position
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        character.HumanoidRootPart.CFrame = originalPosition
                    end
                    
                    break
                end
            end
        end
    end
})
