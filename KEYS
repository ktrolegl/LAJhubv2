-- LAJ HUB Key System with Enhanced Webhook Functionality
-- Combines key verification system with advanced webhook tracking
-- Created for GitHub deployment

-- Module definition
local KeySystem = {}

-- Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")
local MarketplaceService = game:GetService("MarketplaceService")

-- Variables
local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

-- Webhook Security Functions
local function encodeWebhook(url)
    if not url or url == "" then return "" end
    
    -- Multiple layers of encoding for better security
    local encoded = ""
    for i = 1, #url do
        -- XOR with a shifting key for each character
        local char = string.byte(url, i)
        local key = (i * 7) % 256
        encoded = encoded .. string.char(bit32.bxor(char, key))
    end
    
    -- Convert to base64 for additional obfuscation
    local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    local result = ''
    local padding = 0
    
    for i = 1, #encoded, 3 do
        local a, b, c = string.byte(encoded, i, i+2)
        b = b or 0
        c = c or 0
        
        if not a then break end
        if not b then padding = 2 elseif not c then padding = 1 end
        
        local triplet = (a * 65536) + (b * 256) + c
        
        for j = 18, 0, -6 do
            local index = bit32.extract(triplet, j, 6) + 1
            result = result .. b64chars:sub(index, index)
        end
    end
    
    if padding == 1 then
        result = result:sub(1, -2) .. "="
    elseif padding == 2 then
        result = result:sub(1, -3) .. "=="
    end
    
    return result
end

local function decodeWebhook(encoded)
    if not encoded or encoded == "" then return "" end
    
    -- Decode base64 first
    local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    local b64indexes = {}
    for i = 1, #b64chars do
        b64indexes[b64chars:sub(i, i)] = i - 1
    end
    
    local padding = 0
    if encoded:sub(-1) == "=" then
        padding = encoded:sub(-2) == "==" and 2 or 1
        encoded = encoded:sub(1, -padding-1)
    end
    
    local decodedBase64 = ""
    for i = 1, #encoded, 4 do
        local n = (b64indexes[encoded:sub(i, i)] * 262144) +
                 (b64indexes[encoded:sub(i+1, i+1)] * 4096) +
                 (b64indexes[encoded:sub(i+2, i+2)] * 64) +
                 (b64indexes[encoded:sub(i+3, i+3)])
        
        decodedBase64 = decodedBase64 .. string.char(
            bit32.extract(n, 16, 8),
            bit32.extract(n, 8, 8),
            bit32.extract(n, 0, 8)
        )
    end
    
    if padding == 1 then
        decodedBase64 = decodedBase64:sub(1, -2)
    elseif padding == 2 then
        decodedBase64 = decodedBase64:sub(1, -3)
    end
    
    -- Decode XOR layer
    local result = ""
    for i = 1, #decodedBase64 do
        local char = string.byte(decodedBase64, i)
        local key = (i * 7) % 256
        result = result .. string.char(bit32.bxor(char, key))
    end
    
    return result
end

-- Store webhook URLs in a more secure way
local ENCODED_WEBHOOKS = {
    default = "", -- Will be set during Init
    userCount = ""  -- Will be set during Init
}

-- Default configuration (will be overridden by Init)
local CONFIG = {
    WebhookURL = nil,
    UserCountWebhookURL = nil,
    KeyList = {},
    GameName = "LAJ HUB",
    DiscordLink = "https://discord.gg/4mgdcfvAJU",
    ScriptURL = nil,
    OnKeyVerified = nil,  -- Callback function when key is verified
    ObfuscateWebhooks = true  -- Enable webhook obfuscation
}

-- Initialize user counter and last webhook time
local userCounter = 0
local lastWebhookTime = 0
local WEBHOOK_COOLDOWN = 300 -- 5 minutes cooldown

-- UI Colors
local Theme = {
    Background = Color3.fromRGB(35, 35, 35),
    DarkBackground = Color3.fromRGB(25, 25, 25),
    TextColor = Color3.fromRGB(255, 255, 255),
    AccentColor = Color3.fromRGB(65, 105, 225),
    ErrorColor = Color3.fromRGB(220, 60, 60),
    SuccessColor = Color3.fromRGB(60, 220, 60)
}

-- Request function for different executors
local function makeHttpRequest(options)
    -- For Swift executor
    if swift and swift.request then
        return swift.request(options)
    end
    
    -- For Synapse and others with http/request libraries
    if syn and syn.request then
        return syn.request(options)
    elseif http and http.request then
        return http.request(options)
    elseif request then
        return request(options)
    elseif HttpService and HttpService.RequestInternal then
        return HttpService:RequestInternal(options)
    else
        warn("No HTTP request function found")
        return {Success = false, Body = "No HTTP request function available"}
    end
end

-- Function to log key usage via webhook
local function logKeyUsage(key, success)
    -- Rate limiting check
    local currentTime = os.time()
    if currentTime - lastWebhookTime < WEBHOOK_COOLDOWN then
        return
    end
    
    -- Don't try to send if webhook URL is not set
    if not CONFIG.WebhookURL or CONFIG.WebhookURL == "" then
        return
    end
    
    local success_pcall, error_message = pcall(function()
        -- Update the timestamp for rate limiting
        lastWebhookTime = currentTime
        
        -- Prepare webhook data
        local webhookData = {
            ["content"] = "",
            ["embeds"] = {{
                ["title"] = success and "LAJ HUB Key Used Successfully" or "Failed Key Attempt",
                ["color"] = success and 65280 or 16711680, -- Green for success, red for failure
                ["fields"] = {
                    {
                        ["name"] = "User",
                        ["value"] = "```" .. Player.Name .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "User ID",
                        ["value"] = "```" .. tostring(Player.UserId) .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Key Used",
                        ["value"] = "```" .. key .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Game",
                        ["value"] = "```" .. MarketplaceService:GetProductInfo(game.PlaceId).Name .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Game ID",
                        ["value"] = "```" .. tostring(game.PlaceId) .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Executor",
                        ["value"] = "```" .. (identifyexecutor and identifyexecutor() or (swift and "Swift" or "Unknown")) .. "```",
                        ["inline"] = true
                    }
                },
                ["footer"] = {
                    ["text"] = "Key Usage Timestamp: " .. os.date("%Y-%m-%d %H:%M:%S")
                }
            }}
        }
        
        -- Send webhook with proper error handling
        local jsonData = HttpService:JSONEncode(webhookData)
        makeHttpRequest({
            Url = CONFIG.WebhookURL,
            Method = 'POST',
            Headers = {
                ['Content-Type'] = 'application/json'
            },
            Body = jsonData
        })
    end)
    
    if not success_pcall then
        warn("Failed to send key webhook: " .. tostring(error_message))
    end
end

-- Function to send usage data to Discord webhook
local function sendUsageData()
    -- Calculate current time for rate limiting
    local currentTime = os.time()
    
    -- Rate limit to 1 request per 5 minutes to prevent webhook abuse
    if currentTime - lastWebhookTime < WEBHOOK_COOLDOWN then
        return
    end
    
    -- Don't try to send if webhook URLs are not set
    if not CONFIG.WebhookURL or CONFIG.WebhookURL == "" then
        return
    end
    
    -- Increment the user counter
    userCounter = userCounter + 1
    
    -- Safely try to send the webhooks
    local success, error_message = pcall(function()
        -- Update the timestamp for rate limiting
        lastWebhookTime = currentTime
        
        -- Prepare the data for the regular usage webhook
        local webhookData = {
            ["content"] = "",
            ["embeds"] = {{
                ["title"] = "LAJ HUB Script Usage! (Swift Compatible)",
                ["type"] = "rich",
                ["color"] = math.random(0, 0xFFFFFF),
                ["fields"] = {
                    {
                        ["name"] = "User:",
                        ["value"] = "```" .. Player.Name .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "User ID:",
                        ["value"] = "```" .. tostring(Player.UserId) .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Game:",
                        ["value"] = "```" .. MarketplaceService:GetProductInfo(game.PlaceId).Name .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Game ID:",
                        ["value"] = "```" .. tostring(game.PlaceId) .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Executor:",
                        ["value"] = "```" .. (identifyexecutor and identifyexecutor() or (swift and "Swift" or "Unknown")) .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Players Active:",
                        ["value"] = "```" .. tostring(Players.NumPlayers) .. "```",
                        ["inline"] = true
                    }
                },
                ["footer"] = {
                    ["text"] = "Script Executed on " .. os.date("%Y-%m-%d %H:%M:%S")
                }
            }}
        }
        
        -- Encode the data and send the first webhook
        local jsonData = HttpService:JSONEncode(webhookData)
        makeHttpRequest({
            Url = CONFIG.WebhookURL,
            Method = 'POST',
            Headers = {
                ['Content-Type'] = 'application/json'
            },
            Body = jsonData
        })
        
        -- Only try to send user count webhook if URL is set
        if CONFIG.UserCountWebhookURL and CONFIG.UserCountWebhookURL ~= "" then
            -- Format time for the user count webhook
            local formattedTime = os.date("%Y-%m-%d %H:%M:%S")
            
            -- Prepare data for the user count webhook
            local countWebhookData = {
                ["content"] = "",
                ["embeds"] = {{
                    ["title"] = "🌟 LAJ HUB Usage Statistics 🌟",
                    ["description"] = "**Script has now been used by " .. tostring(userCounter) .. " players!**\n\n*A new player has just executed LAJ HUB*",
                    ["color"] = 0x7289DA, -- Discord blue color
                    ["thumbnail"] = {
                        ["url"] = "https://i.imgur.com/QV7nVFU.png" -- You can replace with your own logo URL
                    },
                    ["fields"] = {
                        {
                            ["name"] = "👤 Latest User",
                            ["value"] = "```" .. Player.Name .. " (" .. tostring(Player.UserId) .. ")```",
                            ["inline"] = true
                        },
                        {
                            ["name"] = "🎮 Game",
                            ["value"] = "```" .. MarketplaceService:GetProductInfo(game.PlaceId).Name .. "```",
                            ["inline"] = true
                        },
                        {
                            ["name"] = "🔧 Executor",
                            ["value"] = "```" .. (identifyexecutor and identifyexecutor() or (swift and "Swift" or "Unknown")) .. "```",
                            ["inline"] = true
                        },
                        {
                            ["name"] = "📊 Total Users",
                            ["value"] = "```yaml\n" .. tostring(userCounter) .. " Users```",
                            ["inline"] = false
                        },
                        {
                            ["name"] = "🔄 Daily Activity",
                            ["value"] = "```diff\n+ New user added to statistics\n+ Counter incremented successfully```",
                            ["inline"] = false
                        }
                    },
                    ["footer"] = {
                        ["text"] = "LAJ HUB Stats • Last Updated: " .. formattedTime,
                        ["icon_url"] = "https://i.imgur.com/QV7nVFU.png"
                    }
                }}
            }
            
            -- Encode and send the user count webhook
            local countJsonData = HttpService:JSONEncode(countWebhookData)
            makeHttpRequest({
                Url = CONFIG.UserCountWebhookURL,
                Method = 'POST',
                Headers = {
                    ['Content-Type'] = 'application/json'
                },
                Body = countJsonData
            })
        end
    end)
    
    if not success then
        warn("Failed to send usage webhook: " .. tostring(error_message))
    end
end

-- Function to log ban/kick events via webhook
local function logBanEvent(reason)
    -- Rate limiting check
    local currentTime = os.time()
    if currentTime - lastWebhookTime < WEBHOOK_COOLDOWN then
        warn("Rate limit: Not sending webhook notification (cooldown active)")
        return
    end
    
    -- Don't try to send if webhook URL is not set
    if not CONFIG.WebhookURL or CONFIG.WebhookURL == "" then
        return
    end
    
    -- Check for anti-spam by validating the reason
    if not reason or reason == "" then
        reason = "Unknown (No reason provided)"
    end
    
    -- Create a unique identifier for this notification to prevent duplicates
    local notificationId = tostring(Player.UserId) .. "_" .. game.PlaceId .. "_" .. os.time()
    
    -- Limit data being sent for privacy and security
    local success, error_message = pcall(function()
        -- Update the timestamp for rate limiting
        lastWebhookTime = currentTime
        
        -- Prepare the webhook data
        local webhookData = {
            ["content"] = "",
            ["embeds"] = {{                  
                ["title"] = "Player Banned/Kicked Alert",
                ["color"] = 16711680, -- Red color for ban alerts
                ["fields"] = {
                    {
                        ["name"] = "User",
                        ["value"] = "```" .. Player.Name .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "User ID",
                        ["value"] = "```" .. tostring(Player.UserId) .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Game",
                        ["value"] = "```" .. MarketplaceService:GetProductInfo(game.PlaceId).Name .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Game ID",
                        ["value"] = "```" .. tostring(game.PlaceId) .. "```",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Ban/Kick Reason",
                        ["value"] = "```" .. (reason or "Unknown") .. "```",
                        ["inline"] = false
                    },
                    {
                        ["name"] = "Notification ID",
                        ["value"] = "```" .. notificationId .. "```",
                        ["inline"] = false
                    }
                },
                ["footer"] = {
                    ["text"] = "Ban/Kick Timestamp: " .. os.date("%Y-%m-%d %H:%M:%S")
                }
            }}
        }
        
        -- Send the webhook
        local jsonData = HttpService:JSONEncode(webhookData)
        makeHttpRequest({
            Url = CONFIG.WebhookURL,
            Method = 'POST',
            Headers = {
                ['Content-Type'] = 'application/json'
            },
            Body = jsonData
        })
    end)
    
    if not success then
        warn("Failed to send ban webhook: " .. tostring(error_message))
    end
end

-- Function to verify a key
local function verifyKey(key)
    for _, validKey in ipairs(CONFIG.KeyList) do
        if key == validKey then
            return true
        end
    end
    return false
end

-- Set up kick/ban detection
local function setupKickDetection()
    -- Set up event listeners for kick/ban detection
    Players.PlayerRemoving:Connect(function(player)
        if player == Player then
            logBanEvent("Player removed from game (possibly kicked/banned)")
        end
    end)
    
    -- Hook for kick detection
    local oldNameCall
    oldNameCall = hookmetamethod(game, "__namecall", function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        if method == "Kick" and self == Player then
            local reason = args[1] or "Unknown"
            logBanEvent(reason)
        end
        
        return oldNameCall(self, ...)
    end)
    
    -- Monitor teleport failures as they often occur during bans
    game:GetService("TeleportService").TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
        if player == Player and (teleportResult == Enum.TeleportResult.Banned or teleportResult == Enum.TeleportResult.GameEnded) then
            logBanEvent("Teleport failed due to ban: " .. errorMessage)
        end
    end)
end

-- Creating UI Elements
local function createKeySystemUI(onKeyVerified)
    -- Check if UI already exists and remove it
    if CoreGui:FindFirstChild("LAJHubKeySystem") then
        CoreGui:FindFirstChild("LAJHubKeySystem"):Destroy()
    end
    
    -- Main ScreenGui
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "LAJHubKeySystem"
    ScreenGui.Parent = CoreGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Main Frame
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Size = UDim2.new(0, 400, 0, 300) -- Slightly increased height for Discord button
    MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.BackgroundColor3 = Theme.Background
    MainFrame.BorderSizePixel = 0
    MainFrame.Parent = ScreenGui
    
    -- Make the frame draggable
    local dragging
    local dragInput
    local dragStart
    local startPos
    
    local function update(input)
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    
    MainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    MainFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
    
    -- Title Bar
    local TitleBar = Instance.new("Frame")
    TitleBar.Name = "TitleBar"
    TitleBar.Size = UDim2.new(1, 0, 0, 30)
    TitleBar.BackgroundColor3 = Theme.DarkBackground
    TitleBar.BorderSizePixel = 0
    TitleBar.Parent = MainFrame
    
    -- Title
    local TitleLabel = Instance.new("TextLabel")
    TitleLabel.Name = "TitleLabel"
    TitleLabel.Size = UDim2.new(1, -60, 1, 0)
    TitleLabel.Position = UDim2.new(0, 10, 0, 0)
    TitleLabel.BackgroundTransparency = 1
    TitleLabel.Font = Enum.Font.SourceSansBold
    TitleLabel.Text = CONFIG.GameName .. " Key System"
    TitleLabel.TextColor3 = Theme.TextColor
    TitleLabel.TextSize = 18
    TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
    TitleLabel.Parent = TitleBar
    
    -- Minimize Button
    local MinimizeButton = Instance.new("TextButton")
    MinimizeButton.Name = "MinimizeButton"
    MinimizeButton.Size = UDim2.new(0, 30, 0, 30)
    MinimizeButton.Position = UDim2.new(1, -60, 0, 0)
    MinimizeButton.BackgroundTransparency = 1
    MinimizeButton.Font = Enum.Font.SourceSansBold
    MinimizeButton.Text = "-"
    MinimizeButton.TextColor3 = Theme.TextColor
    MinimizeButton.TextSize = 24
    MinimizeButton.Parent = TitleBar
    
    -- Close Button
    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "CloseButton"
    CloseButton.Size = UDim2.new(0, 30, 0, 30)
    CloseButton.Position = UDim2.new(1, -30, 0, 0)
    CloseButton.BackgroundTransparency = 1
    CloseButton.Font = Enum.Font.SourceSansBold
    CloseButton.Text = "×"
    CloseButton.TextColor3 = Theme.TextColor
    CloseButton.TextSize = 24
    CloseButton.Parent = TitleBar
    
    -- Close button action
    CloseButton.MouseButton1Click:Connect(function()
        ScreenGui:Destroy()
    end)
    
    -- Content Area
    local ContentArea = Instance.new("Frame")
    ContentArea.Name = "ContentArea"
    ContentArea.Size = UDim2.new(1, 0, 1, -30)
    ContentArea.Position = UDim2.new(0, 0, 0, 30)
    ContentArea.BackgroundTransparency = 1
    ContentArea.Parent = MainFrame
    
    -- Logo (if available)
    local LogoImage = Instance.new("ImageLabel")
    LogoImage.Name = "LogoImage"
    LogoImage.Size = UDim2.new(0, 100, 0, 100)
    LogoImage.Position = UDim2.new(0.5, 0, 0, 20)
    LogoImage.AnchorPoint = Vector2.new(0.5, 0)
    LogoImage.BackgroundTransparency = 1
    LogoImage.Image = "rbxassetid://15159281768" -- Replace with your logo asset ID
    LogoImage.Parent = ContentArea
    
    -- Key Label
    local KeyLabel = Instance.new("TextLabel")
    KeyLabel.Name = "KeyLabel"
    KeyLabel.Size = UDim2.new(1, -40, 0, 20)
    KeyLabel.Position = UDim2.new(0, 20, 0, 130)
    KeyLabel.BackgroundTransparency = 1
    KeyLabel.Font = Enum.Font.SourceSansBold
    KeyLabel.Text = "Enter Key:"
    KeyLabel.TextColor3 = Theme.TextColor
    KeyLabel.TextSize = 18
    KeyLabel.TextXAlignment = Enum.TextXAlignment.Left
    KeyLabel.Parent = ContentArea
    
    -- Key Input
    local KeyInput = Instance.new("TextBox")
    KeyInput.Name = "KeyInput"
    KeyInput.Size = UDim2.new(1, -40, 0, 35)
    KeyInput.Position = UDim2.new(0, 20, 0, 155)
    KeyInput.BackgroundColor3 = Theme.DarkBackground
    KeyInput.BorderSizePixel = 0
    KeyInput.Font = Enum.Font.SourceSans
    KeyInput.PlaceholderText = "Enter your key here..."
    KeyInput.Text = ""
    KeyInput.TextColor3 = Theme.TextColor
    KeyInput.TextSize = 16
    KeyInput.ClearTextOnFocus = false
    KeyInput.Parent = ContentArea
    
    -- Status Label
    local StatusLabel = Instance.new("TextLabel")
    StatusLabel.Name = "StatusLabel"
    StatusLabel.Size = UDim2.new(1, -40, 0, 20)
    StatusLabel.Position = UDim2.new(0, 20, 0, 195)
    StatusLabel.BackgroundTransparency = 1
    StatusLabel.Font = Enum.Font.SourceSans
    StatusLabel.Text = "Enter your key and click Verify"
    StatusLabel.TextColor3 = Theme.TextColor
    StatusLabel.TextSize = 16
    StatusLabel.TextXAlignment = Enum.TextXAlignment.Center
    StatusLabel.Parent = ContentArea
    
    -- Verify Button
    local VerifyButton = Instance.new("TextButton")
    VerifyButton.Name = "VerifyButton"
    VerifyButton.Size = UDim2.new(1, -40, 0, 35)
    VerifyButton.Position = UDim2.new(0, 20, 0, 220)
    VerifyButton.BackgroundColor3 = Theme.AccentColor
    VerifyButton.BorderSizePixel = 0
    VerifyButton.Font = Enum.Font.SourceSansBold
    VerifyButton.Text = "Verify Key"
    VerifyButton.TextColor3 = Theme.TextColor
    VerifyButton.TextSize = 18
    VerifyButton.Parent = ContentArea
    
    -- Discord Button
    local DiscordButton = Instance.new("TextButton")
    DiscordButton.Name = "DiscordButton"
    DiscordButton.Size = UDim2.new(1, -40, 0, 30)
    DiscordButton.Position = UDim2.new(0, 20, 1, -45)
    DiscordButton.BackgroundColor3 = Color3.fromRGB(88, 101, 242) -- Discord blue
    DiscordButton.BorderSizePixel = 0
    DiscordButton.Font = Enum.Font.SourceSansBold
    DiscordButton.Text = "Join Discord for Key"
    DiscordButton.TextColor3 = Theme.TextColor
    DiscordButton.TextSize = 16
    DiscordButton.Parent = ContentArea
    
    -- Set up button hover effects
    for _, button in pairs({VerifyButton, DiscordButton}) do
        button.MouseEnter:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = button.BackgroundColor3:Lerp(Color3.fromRGB(255, 255, 255), 0.2)}):Play()
        end)
        
        button.MouseLeave:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = button.BackgroundColor3:Lerp(Color3.fromRGB(0, 0, 0), 0.1)}):Play()
        end)
    end
    
    -- Verify button action
    VerifyButton.MouseButton1Click:Connect(function()
        local key = KeyInput.Text
        
        if key == "" then
            StatusLabel.Text = "Please enter a key"
            StatusLabel.TextColor3 = Theme.ErrorColor
            return
        end
        
        -- Verify the key
        local isValid = verifyKey(key)
        
        if isValid then
            -- Successful verification
            StatusLabel.Text = "Key verified successfully!"
            StatusLabel.TextColor3 = Theme.SuccessColor
            
            -- Log successful key usage
            logKeyUsage(key, true)
            
            -- Send usage data to webhook
            sendUsageData()
            
            -- Create success animation
            local oldColor = VerifyButton.BackgroundColor3
            VerifyButton.BackgroundColor3 = Theme.SuccessColor
            VerifyButton.Text = "Success!"
            
            wait(1)
            
            -- Call the verification callback
            if onKeyVerified then
                onKeyVerified(key)
            end
            
            -- Close the UI after loading the script
            wait(0.5)
            ScreenGui:Destroy()
        else
            -- Failed verification
            StatusLabel.Text = "Invalid key. Try again or join Discord."
            StatusLabel.TextColor3 = Theme.ErrorColor
            
            -- Log failed key attempt
            logKeyUsage(key, false)
            
            -- Create error animation
            local oldColor = VerifyButton.BackgroundColor3
            VerifyButton.BackgroundColor3 = Theme.ErrorColor
            VerifyButton.Text = "Invalid Key"
            
            wait(1)
            
            -- Reset button
            VerifyButton.BackgroundColor3 = Theme.AccentColor
            VerifyButton.Text = "Verify Key"
        end
    end)
    
    DiscordButton.MouseButton1Click:Connect(function()
        -- Open Discord invite
        pcall(function()
            setclipboard(CONFIG.DiscordLink)
        end)
        
        StatusLabel.Text = "Discord link copied to clipboard!"
        StatusLabel.TextColor3 = Color3.fromRGB(114, 137, 218)
    end)
    
    -- Minimize button action
    local isMinimized = false
    MinimizeButton.MouseButton1Click:Connect(function()
        isMinimized = not isMinimized
        
        if isMinimized then
            -- Minimize animation
            local targetSize = UDim2.new(0, 400, 0, 30)
            local targetContentPos = UDim2.new(0, 0, 0, 0)
            
            TweenService:Create(MainFrame, TweenInfo.new(0.3), {Size = targetSize}):Play()
            ContentArea.Visible = false
            MinimizeButton.Text = "+"
        else
            -- Restore animation
            local targetSize = UDim2.new(0, 400, 0, 300)
            
            TweenService:Create(MainFrame, TweenInfo.new(0.3), {Size = targetSize}):Play()
            wait(0.3)
            ContentArea.Visible = true
            MinimizeButton.Text = "-"
        end
    end)
    
    -- Drop shadow effect
    local DropShadow = Instance.new("ImageLabel")
    DropShadow.Name = "DropShadow"
    DropShadow.Size = UDim2.new(1, 20, 1, 20)
    DropShadow.Position = UDim2.new(0.5, 0, 0.5, 0)
    DropShadow.AnchorPoint = Vector2.new(0.5, 0.5)
    DropShadow.BackgroundTransparency = 1
    DropShadow.Image = "rbxassetid://6014261993"
    DropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    DropShadow.ImageTransparency = 0.5
    DropShadow.ScaleType = Enum.ScaleType.Slice
    DropShadow.SliceCenter = Rect.new(49, 49, 450, 450)
    DropShadow.ZIndex = -1
    DropShadow.Parent = MainFrame
end

-- Expose webhook functions for external use
KeySystem.sendUsageData = sendUsageData
KeySystem.logKeyUsage = logKeyUsage
KeySystem.logBanEvent = logBanEvent

-- Main initialization function
function KeySystem.Init(config)
    -- Update configuration with provided values
    for key, value in pairs(config) do
        CONFIG[key] = value
    end
    
    -- Validate required configuration
    if not CONFIG.KeyList or #CONFIG.KeyList == 0 then
        warn("KeySystem.Init: No valid keys provided in configuration")
        return false
    end
    
    -- Set up kick detection
    spawn(function()
        setupKickDetection()
    end)
    
    -- Create and show the key system UI
    createKeySystemUI(CONFIG.OnKeyVerified)
    
    return true
end

-- Return the module
return KeySystem
